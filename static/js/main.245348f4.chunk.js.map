{"version":3,"sources":["components/MapComponent.js","components/ButtonPanel.js","App.js","index.js"],"names":["MapComponent","React","forwardRef","_ref","ref","markers","route","onMapClick","onMarkerClick","handleFindLocation","onMarkerDragEnd","useEffect","console","log","getIcon","type","emoji","backgroundColor","L","DivIcon","html","concat","className","_jsxs","Map","center","zoom","style","height","width","onClick","children","_jsx","TileLayer","url","attribution","ScaleControl","position","Search","map","marker","idx","Marker","lat","lng","icon","draggable","eventHandlers","click","dragend","e","target","getLatLng","getRouteSegments","segments","i","length","push","positions","color","segment","Polyline","ButtonPanel","onFindLocation","setMode","distances","currentPolylineDistance","lastPointDistance","clearRoute","undoLastPoint","swim","toFixed","run","defaultProps","App","mapRef","useRef","mode","useState","setMarkers","setRoute","setDistances","setCurrentPolylineDistance","setLastPointDistance","editingIndex","setEditingIndex","navigator","geolocation","getCurrentPosition","latitude","longitude","coords","current","setView","error","alert","checkIfOnLand","point","turf","polygon","landPolygons","features","checkIfOnWater","waterPolygons","calculateDistance","newMarker","lastMarker","distance","getDistance","prev","lat1","lon1","lat2","lon2","dLat","Math","PI","dLon","a","sin","cos","atan2","sqrt","updateDistances","updatedRoute","swimDistance","runDistance","polylineDistance","latlng","polylineType","determinePolylineType","isStartOnLand","isEndOnLand","isStartOnWater","isEndOnWater","updatedMarkers","index","slice","secondLastMarker","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.245348f4.chunk.js","sourcesContent":["import React, { useEffect } from 'react';\nimport { Map, TileLayer, Marker, Polyline, ScaleControl } from 'react-leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport L from 'leaflet';\nimport Search from 'react-leaflet-search';\n\n// Define the MapComponent as a forwardRef component\nconst MapComponent = React.forwardRef(({ markers, route, onMapClick, onMarkerClick, handleFindLocation, onMarkerDragEnd }, ref) => {\n\n  useEffect(() => {\n    console.log(\"MapComponent mounted\");\n    console.log(\"Markers: \", markers);\n    console.log(\"Route: \", route);\n  }, [markers, route]);\n\n  // Function to create custom icons based on the marker type\n  const getIcon = (type) => {\n    let emoji;\n    let backgroundColor;\n\n    if (type === 'start') {\n      emoji = 'ğŸŸ¢'; // Green circle for start\n      backgroundColor = 'rgba(0, 128, 0, 0.5)';\n    } else if (type === 'swim') {\n      emoji = 'ğŸŠ';\n      backgroundColor = 'rgba(0, 0, 255, 0.5)';\n    } else if (type === 'run') {\n      emoji = 'ğŸƒ';\n      backgroundColor = 'rgba(255, 165, 0, 0.5)';\n    } else if (type === 'stop') {\n      emoji = 'ğŸ'; // Checkered flag for stop\n      backgroundColor = 'rgba(0, 0, 0, 0.5)';\n    }\n\n    return new L.DivIcon({\n      html: `<div style=\"background-color: ${backgroundColor}; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;\"><span style=\"font-size: 24px;\">${emoji}</span></div>`,\n      className: '',\n    });\n  };\n\n  // Function to get the color of the route segment based on the type\n  const getColor = (type) => {\n    return type === 'swim' ? '#2980b9' : '#e67e22';\n  };\n\n  // Function to generate the route segments for rendering\n  const getRouteSegments = () => {\n    const segments = [];\n    for (let i = 0; i < route.length - 1; i++) {\n      segments.push({\n        positions: [[route[i].lat, route[i].lng], [route[i + 1].lat, route[i + 1].lng]],\n        color: getColor(route[i].type),\n      });\n    }\n    return segments;\n  };\n\n  return (\n    <Map\n      center={[51.505, -0.09]}\n      zoom={13}\n      style={{ height: '100%', width: '100%' }}\n      ref={ref}\n      onClick={onMapClick}\n    >\n      <TileLayer\n        url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n      />\n      <ScaleControl position=\"bottomleft\" />\n      <Search position=\"topright\" />\n      {markers.map((marker, idx) => (\n        <Marker\n          key={idx}\n          position={[marker.lat, marker.lng]}\n          icon={getIcon(marker.type)}\n          draggable={true}\n          eventHandlers={{\n            click: () => onMarkerClick(idx),\n            dragend: (e) => {\n              const { lat, lng } = e.target.getLatLng();\n              onMarkerDragEnd(idx, lat, lng);\n            },\n          }}\n        />\n      ))}\n      {getRouteSegments().map((segment, idx) => (\n        <Polyline\n          key={idx}\n          positions={segment.positions}\n          color={segment.color}\n        />\n      ))}\n      <div className=\"find-location-btn\" onClick={handleFindLocation}>ğŸ“</div>\n    </Map>\n  );\n});\n\nexport default MapComponent;","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './ButtonPanel.css';\n\nconst ButtonPanel = ({ onFindLocation, setMode, distances, currentPolylineDistance, lastPointDistance, clearRoute, undoLastPoint }) => {\n  return (\n    <div className=\"button-panel\">\n      <div className=\"button-row\">\n        <button className=\"button-highlight\" onClick={() => setMode('swim')}>ğŸŠ Start Swim</button>\n        <button className=\"button-highlight\" onClick={() => setMode('run')}>ğŸƒ Start Run</button>\n        <button className=\"button-secondary\" onClick={() => setMode('stop')}>ğŸ Stop Route</button>\n      </div>\n      <div className=\"button-row\">\n        <button className=\"button-primary\" onClick={onFindLocation}>ğŸ“ Find my location</button>\n        <button className=\"button-secondary\" onClick={clearRoute}>ğŸ—‘ï¸ Clear Route</button>\n        <button className=\"button-secondary\" onClick={undoLastPoint}>â†©ï¸ Undo</button>\n      </div>\n      <div className=\"distances\">\n        <p>Swim: <span className=\"distance-highlight\">{distances.swim.toFixed(2)} km</span></p>\n        <p>Run: <span className=\"distance-highlight\">{distances.run.toFixed(2)} km</span></p>\n        <p>Total: <span className=\"distance-highlight\">{currentPolylineDistance.toFixed(2)} km</span></p>\n        <p>Last added: <span className=\"distance-highlight\">{lastPointDistance.toFixed(2)} km</span></p>\n      </div>\n    </div>\n  );\n};\n\nButtonPanel.propTypes = {\n  onFindLocation: PropTypes.func,\n  setMode: PropTypes.func.isRequired,\n  distances: PropTypes.shape({\n    swim: PropTypes.number,\n    run: PropTypes.number,\n  }).isRequired,\n  currentPolylineDistance: PropTypes.number.isRequired,\n  lastPointDistance: PropTypes.number.isRequired,\n  clearRoute: PropTypes.func.isRequired,\n  undoLastPoint: PropTypes.func.isRequired,\n};\n\nButtonPanel.defaultProps = {\n  onFindLocation: () => {},\n};\n\nexport default ButtonPanel;","import React from 'react';\nimport MapComponent from './components/MapComponent';\nimport ButtonPanel from './components/ButtonPanel';\nimport './App.css';\nimport 'leaflet/dist/leaflet.css';\nimport * as turf from '@turf/turf';\nimport landPolygons from './data/land_polygons.json';\nimport waterPolygons from './data/water_polygons.json';\n\nfunction App() {\n  const mapRef = React.useRef();\n  const [mode, setMode] = React.useState(null); // 'swim', 'run', 'stop'\n  const [markers, setMarkers] = React.useState([]);\n  const [route, setRoute] = React.useState([]);\n  const [distances, setDistances] = React.useState({ swim: 0, run: 0 });\n  const [currentPolylineDistance, setCurrentPolylineDistance] = React.useState(0); // Current polyline distance\n  const [lastPointDistance, setLastPointDistance] = React.useState(0); // Distance of the last added point\n  const [editingIndex, setEditingIndex] = React.useState(null);\n\n  const handleFindLocation = () => {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition((position) => {\n        const { latitude, longitude } = position.coords;\n        if (mapRef.current) {\n          mapRef.current.setView([latitude, longitude], 13);\n        } else {\n          console.error(\"Map reference is not available\");\n        }\n      });\n    } else {\n      alert('Geolocation is not supported by this browser.');\n    }\n  };\n\n  const checkIfOnLand = (lat, lng) => {\n    const point = turf.point([lng, lat]);\n\n    for (const polygon of landPolygons.features) {\n      if (turf.booleanPointInPolygon(point, polygon)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const checkIfOnWater = (lat, lng) => {\n    const point = turf.point([lng, lat]);\n\n    for (const polygon of waterPolygons.features) {\n      if (turf.booleanPointInPolygon(point, polygon)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const determinePolylineType = (lat1, lon1, lat2, lon2) => {\n    const isStartOnLand = checkIfOnLand(lat1, lon1);\n    const isEndOnLand = checkIfOnLand(lat2, lon2);\n\n    if (isStartOnLand && isEndOnLand) {\n      return 'run';\n    }\n\n    const isStartOnWater = checkIfOnWater(lat1, lon1);\n    const isEndOnWater = checkIfOnWater(lat2, lon2);\n\n    if (isStartOnWater && isEndOnWater) {\n      return 'swim';\n    }\n\n    return 'unknown';\n  };\n\n  const handleMapClick = (e) => {\n    const { lat, lng } = e.latlng;\n    const newMarker = { lat, lng, type: mode };\n\n    if (route.length > 0) {\n      const lastMarker = route[route.length - 1];\n      const polylineType = determinePolylineType(lastMarker.lat, lastMarker.lng, lat, lng);\n      newMarker.type = polylineType;\n    }\n\n    if (editingIndex !== null) {\n      const updatedMarkers = [...markers];\n      const updatedRoute = [...route];\n      updatedMarkers[editingIndex] = newMarker;\n      updatedRoute[editingIndex] = newMarker;\n      setMarkers(updatedMarkers);\n      setRoute(updatedRoute);\n      setEditingIndex(null);\n    } else {\n      if (route.length === 0) {\n        setMarkers([{ ...newMarker, type: 'start' }, newMarker]);\n        setRoute([newMarker]);\n      } else {\n        setMarkers([...markers, newMarker]);\n        setRoute([...route, newMarker]);\n      }\n      calculateDistance(newMarker);\n    }\n  };\n\n  const calculateDistance = (newMarker) => {\n    if (route.length > 0) {\n      const lastMarker = route[route.length - 1];\n      const distance = getDistance(lastMarker.lat, lastMarker.lng, newMarker.lat, newMarker.lng);\n      setCurrentPolylineDistance((prev) => prev + distance); // Update current polyline distance\n      setLastPointDistance(distance); // Update last point distance\n\n      if (newMarker.type === 'swim') {\n        setDistances((prev) => ({ ...prev, swim: prev.swim + distance }));\n      } else if (newMarker.type === 'run') {\n        setDistances((prev) => ({ ...prev, run: prev.run + distance }));\n      }\n    }\n  };\n\n  const getDistance = (lat1, lon1, lat2, lon2) => {\n    const R = 6371; // Radius of the Earth in kilometers\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLon = (lon2 - lon1) * Math.PI / 180;\n    const a = \n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n      Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c; // Distance in kilometers\n    return distance;\n  };\n\n  const clearRoute = () => {\n    setMarkers([]);\n    setRoute([]);\n    setDistances({ swim: 0, run: 0 });\n    setCurrentPolylineDistance(0); // Reset current polyline distance when clearing\n    setLastPointDistance(0); // Reset last point distance when clearing\n  };\n\n  const undoLastPoint = () => {\n    if (markers.length > 1) {\n      const updatedMarkers = markers.slice(0, -1);\n      const updatedRoute = route.slice(0, -1);\n      const lastMarker = markers[markers.length - 1];\n      const secondLastMarker = markers[markers.length - 2];\n      const distance = getDistance(secondLastMarker.lat, secondLastMarker.lng, lastMarker.lat, lastMarker.lng);\n\n      setMarkers(updatedMarkers);\n      setRoute(updatedRoute);\n\n      if (lastMarker.type === 'swim') {\n        setDistances((prev) => ({ ...prev, swim: prev.swim - distance }));\n      } else if (lastMarker.type === 'run') {\n        setDistances((prev) => ({ ...prev, run: prev.run - distance }));\n      }\n      setCurrentPolylineDistance((prev) => prev - distance);\n      setLastPointDistance(0); // Reset last point distance when undoing\n    } else {\n      clearRoute();\n    }\n  };\n\n  const handleMarkerClick = (index) => {\n    setEditingIndex(index);\n  };\n\n  const onMarkerDragEnd = (index, lat, lng) => {\n    const updatedMarkers = [...markers];\n    const updatedRoute = [...route];\n    updatedMarkers[index] = { ...updatedMarkers[index], lat, lng };\n    updatedRoute[index] = { ...updatedRoute[index], lat, lng };\n    setMarkers(updatedMarkers);\n    setRoute(updatedRoute);\n    updateDistances(updatedRoute);\n  };\n\n  const updateDistances = (updatedRoute) => {\n    let swimDistance = 0;\n    let runDistance = 0;\n    let polylineDistance = 0;\n    for (let i = 0; i < updatedRoute.length - 1; i++) {\n      const distance = getDistance(\n        updatedRoute[i].lat,\n        updatedRoute[i].lng,\n        updatedRoute[i + 1].lat,\n        updatedRoute[i + 1].lng\n      );\n      polylineDistance += distance;\n      if (updatedRoute[i].type === 'swim') {\n        swimDistance += distance;\n      } else if (updatedRoute[i].type === 'run') {\n        runDistance += distance;\n      }\n    }\n    setDistances({ swim: swimDistance, run: runDistance });\n    setCurrentPolylineDistance(polylineDistance);\n    if (updatedRoute.length > 1) {\n      setLastPointDistance(\n        getDistance(\n          updatedRoute[updatedRoute.length - 2].lat,\n          updatedRoute[updatedRoute.length - 2].lng,\n          updatedRoute[updatedRoute.length - 1].lat,\n          updatedRoute[updatedRoute.length - 1].lng\n        )\n      );\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"map-container\">\n        <MapComponent\n          ref={mapRef}\n          markers={markers}\n          route={route}\n          onMapClick={handleMapClick}\n          onMarkerClick={handleMarkerClick}\n          handleFindLocation={handleFindLocation}\n          onMarkerDragEnd={onMarkerDragEnd}\n        />\n      </div>\n      <ButtonPanel\n        setMode={setMode}\n        clearRoute={clearRoute}\n        distances={distances}\n        currentPolylineDistance={currentPolylineDistance} // Pass current polyline distance\n        lastPointDistance={lastPointDistance} // Pass last point distance\n        onFindLocation={handleFindLocation}\n        undoLastPoint={undoLastPoint}\n      />\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}